#ifndef CHESS_H
#define CHESS_H

#include <cstdint>
#include <string>
#include <vector>
#include <array>

// Tipos básicos
using Bitboard = uint64_t;
using Square = int;

// Constantes de cores
enum Color : int {
    WHITE = 0,
    BLACK = 1
};

// Constantes de peças
enum PieceType : int {
    PAWN = 0,
    KNIGHT = 1,
    BISHOP = 2,
    ROOK = 3,
    QUEEN = 4,
    KING = 5,
    NONE = 6
};

// Constantes de casas (A1..H8)
enum SquareEnum : Square {
    A1 = 0, B1, C1, D1, E1, F1, G1, H1,
    A2, B2, C2, D2, E2, F2, G2, H2,
    A3, B3, C3, D3, E3, F3, G3, H3,
    A4, B4, C4, D4, E4, F4, G4, H4,
    A5, B5, C5, D5, E5, F5, G5, H5,
    A6, B6, C6, D6, E6, F6, G6, H6,
    A7, B7, C7, D7, E7, F7, G7, H7,
    A8, B8, C8, D8, E8, F8, G8, H8,
    NO_SQUARE = 64
};

// Estrutura para representar um movimento
struct Move {
    Square from;
    Square to;
    PieceType promotion;
    bool is_castle;
    bool is_en_passant;
    
    Move() : from(NO_SQUARE), to(NO_SQUARE), promotion(NONE), 
             is_castle(false), is_en_passant(false) {}
    
    Move(Square f, Square t, PieceType p = NONE) 
        : from(f), to(t), promotion(p), is_castle(false), 
          is_en_passant(false) {}
    
    bool operator==(const Move& other) const {
        return from == other.from && to == other.to && promotion == other.promotion;
    }
    
    std::string to_string() const;
    static Move from_string(const std::string& move_str);
};

// Classe principal do tabuleiro
class ChessBoard {
    friend class ChessEngine; // Permite acesso rápido para a engine

private:
    std::array<Bitboard, 6> pieces_white;
    std::array<Bitboard, 6> pieces_black;
    Bitboard all_white;
    Bitboard all_black;
    Bitboard all_pieces;
    
    Color side_to_move;
    Square en_passant_square;
    bool castling_rights[2][2];
    int halfmove_clock;
    int fullmove_number;
    
    //Zobrist Hash
    uint64_t current_hash;

    // Tabelas de números aleatórios para o Hash
    static uint64_t zobrist_pieces[2][6][64]; // [Color][Piece][Square]
    static uint64_t zobrist_side;             // Lado a jogar
    static uint64_t zobrist_castling[4];      // [WK, WQ, BK, BQ]
    static uint64_t zobrist_enpassant[8];     // Arquivo A-H

    // Função para inicializar os números aleatórios
    static void init_zobrist();


    // [CRÍTICO] Estrutura robusta para o histórico
    struct GameState {
        Move move;
        Square en_passant_square;
        bool castling_rights[2][2];
        int halfmove_clock;
        PieceType captured_piece;
        Square captured_square;
        PieceType moved_piece; 
    };
    std::vector<GameState> history;
    
    // Lookup tables estáticas
    static std::array<Bitboard, 64> knight_moves;
    static std::array<Bitboard, 64> king_moves;
    static std::array<std::array<Bitboard, 64>, 4> pawn_attacks;
    static std::array<Bitboard, 64> pawn_pushes_white;
    static std::array<Bitboard, 64> pawn_pushes_black;
    
    void initialize_lookup_tables();
    void update_bitboards();
    
    Bitboard get_attacks_to(Square sq, Color attacker_color) const;
    bool is_square_attacked(Square sq, Color by_color) const;
    
    // Getters de ataques
    Bitboard get_pawn_attacks(Square sq, Color c) const;
    Bitboard get_knight_attacks(Square sq) const;
    Bitboard get_bishop_attacks(Square sq, Bitboard occupied) const;
    Bitboard get_rook_attacks(Square sq, Bitboard occupied) const;
    Bitboard get_queen_attacks(Square sq, Bitboard occupied) const;
    Bitboard get_king_attacks(Square sq) const;
    Bitboard get_attacks_by(Square sq, PieceType pt, Color c) const;
    
    // Geração
    void generate_pawn_moves(std::vector<Move>& moves, Color c) const;
    void generate_knight_moves(std::vector<Move>& moves, Color c) const;
    void generate_bishop_moves(std::vector<Move>& moves, Color c) const;
    void generate_rook_moves(std::vector<Move>& moves, Color c) const;
    void generate_queen_moves(std::vector<Move>& moves, Color c) const;
    void generate_king_moves(std::vector<Move>& moves, Color c) const;
    void generate_castling_moves(std::vector<Move>& moves, Color c) const;
    
    bool is_legal_move(const Move& move) const;
    void make_move_internal(const Move& move);
    
public:
    ChessBoard();
    ChessBoard(const std::string& fen);
    
    std::vector<Move> generate_legal_moves() const;
    bool make_move(const Move& move);
    void unmake_move();
    
    bool is_check(Color c) const;
    bool is_checkmate(Color c) const;
    bool is_stalemate(Color c) const;
    bool is_game_over() const;
    
    PieceType get_piece(Square sq) const;
    Color get_piece_color(Square sq) const;
    
    // --- Getters adicionados para corrigir o erro da GUI ---
    Color get_side_to_move() const { return side_to_move; }
    int get_fullmove_number() const { return fullmove_number; }
    int get_halfmove_clock() const { return halfmove_clock; }
    // ------------------------------------------------------
    
    // [NOVO] Gera a notação SAN para um movimento
    std::string move_to_san(const Move& move);
    
    void print_board() const;
    std::string to_fen() const;
    void from_fen(const std::string& fen);
    
    static Square square_from_string(const std::string& str);
    static std::string square_to_string(Square sq);
    static int get_file(Square sq) { return sq & 7; }
    static int get_rank(Square sq) { return sq >> 3; }
    static Square make_square(int file, int rank) { return rank * 8 + file; }

    uint64_t get_hash() const { return current_hash; }
    
    // [NOVO] Recalcula o hash do zero (para validação ou init)
    uint64_t compute_hash() const;
    
};

#endif // CHESS_H